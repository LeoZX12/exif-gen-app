<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>EXIF Border Generator</title>
<meta name="description" content="Add beautiful borders with camera metadata to your photos">
<meta name="theme-color" content="#000000">

<!-- PWA Meta Tags -->
<meta name="mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="EXIF Border">
<link rel="apple-touch-icon" href="icons/icon-192.png">

<link rel="manifest" href="manifest.json">
<link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üì∑</text></svg>">
<script src="https://cdn.jsdelivr.net/npm/exif-js"></script>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">

<style>
/* Reset & Base */
* {
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
  box-sizing: border-box;
  cursor: default;
}

input, select, textarea, button {
  -webkit-user-select: text;
  -moz-user-select: text;
  -ms-user-select: text;
  user-select: text;
  cursor: auto;
}

:root {
  --bg: #ffffff;
  --surface: #f8fafc;
  --card: #ffffff;
  --text: #0f172a;
  --text-secondary: #64748b;
  --border: #e2e8f0;
  --primary: #000000;
  --primary-light: rgba(0, 0, 0, 0.05);
  --accent: #3b82f6;
  --radius-sm: 8px;
  --radius-md: 12px;
  --radius-lg: 16px;
  --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
  --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
  --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
  --transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
}

[data-theme="dark"] {
  --bg: #0f172a;
  --surface: #1e293b;
  --card: #1e293b;
  --text: #f8fafc;
  --text-secondary: #94a3b8;
  --border: #334155;
  --primary: #ffffff;
  --primary-light: rgba(255, 255, 255, 0.1);
  --accent: #60a5fa;
}

body {
  margin: 0;
  padding: 0;
  font-family: 'Inter', -apple-system, BlinkMacSystemFont, system-ui, sans-serif;
  background: var(--bg);
  color: var(--text);
  transition: var(--transition);
  min-height: 100vh;
  line-height: 1.5;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

.wrapper {
  max-width: 1200px;
  margin: 0 auto;
  padding: clamp(1.5rem, 5vw, 2.5rem) clamp(1rem, 4vw, 2rem);
}

/* Header */
header {
  display: flex;
  align-items: flex-start;
  justify-content: space-between;
  margin-bottom: 2.5rem;
  flex-wrap: wrap;
  gap: 1.5rem;
}

.header-content h1 {
  font-size: clamp(1.75rem, 4vw, 2.5rem);
  font-weight: 700;
  letter-spacing: -0.025em;
  margin: 0 0 0.5rem 0;
  background: linear-gradient(135deg, var(--text) 0%, var(--text-secondary) 100%);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}

.header-content p {
  color: var(--text-secondary);
  margin: 0;
  font-size: 0.95rem;
  max-width: 36ch;
}

/* Theme Toggle */
.theme-toggle {
  background: transparent;
  border: 1.5px solid var(--border);
  color: var(--text);
  padding: 0.625rem 1.25rem;
  border-radius: var(--radius-md);
  cursor: pointer;
  font-size: 0.875rem;
  font-weight: 500;
  display: flex;
  align-items: center;
  gap: 0.5rem;
  transition: var(--transition);
  backdrop-filter: blur(10px);
  background: rgba(255, 255, 255, 0.05);
}

.theme-toggle:hover {
  border-color: var(--accent);
  transform: translateY(-1px);
}

.theme-toggle::before {
  content: '';
  display: inline-block;
  width: 16px;
  height: 16px;
  background: currentColor;
  mask-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='currentColor'%3E%3Cpath d='M12 2.25a.75.75 0 01.75.75v2.25a.75.75 0 01-1.5 0V3a.75.75 0 01.75-.75zM7.5 12a4.5 4.5 0 119 0 4.5 4.5 0 01-9 0zM18.894 6.166a.75.75 0 00-1.06-1.06l-1.591 1.59a.75.75 0 101.06 1.061l1.591-1.59zM21.75 12a.75.75 0 01-.75.75h-2.25a.75.75 0 010-1.5H21a.75.75 0 01.75.75zM17.834 18.894a.75.75 0 001.06-1.06l-1.59-1.591a.75.75 0 10-1.061 1.06l1.59 1.591zM12 18a.75.75 0 01.75.75V21a.75.75 0 01-1.5 0v-2.25A.75.75 0 0112 18zM7.758 17.303a.75.75 0 00-1.061-1.06l-1.591 1.59a.75.75 0 001.06 1.061l1.591-1.59zM6 12a.75.75 0 01-.75.75H3a.75.75 0 010-1.5h2.25A.75.75 0 016 12zM6.697 7.757a.75.75 0 001.06-1.06l-1.59-1.591a.75.75 0 00-1.061 1.06l1.59 1.591z'/%3E%3C/svg%3E");
  mask-repeat: no-repeat;
  mask-position: center;
}

[data-theme="dark"] .theme-toggle::before {
  mask-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='currentColor'%3E%3Cpath fill-rule='evenodd' d='M9.528 1.718a.75.75 0 01.162.819A8.97 8.97 0 009 6a9 9 0 009 9 8.97 8.97 0 003.463-.69.75.75 0 01.981.98 10.503 10.503 0 01-9.694 6.46c-5.799 0-10.5-4.701-10.5-10.5 0-4.368 2.667-8.112 6.46-9.694a.75.75 0 01.818.162z' clip-rule='evenodd'/%3E%3C/svg%3E");
}

/* Card */
.card {
  background: var(--card);
  border-radius: var(--radius-lg);
  padding: clamp(1.5rem, 4vw, 2.5rem);
  transition: var(--transition);
  border: 1px solid var(--border);
  box-shadow: var(--shadow-md);
}

/* Upload Area */
.upload-area {
  border: 2px dashed var(--border);
  border-radius: var(--radius-md);
  padding: clamp(3rem, 8vw, 5rem) 2rem;
  text-align: center;
  cursor: pointer;
  margin-bottom: 2.5rem;
  transition: var(--transition);
  background: var(--primary-light);
  position: relative;
  overflow: hidden;
}

.upload-area:hover {
  border-color: var(--accent);
  transform: translateY(-2px);
  box-shadow: var(--shadow-lg);
}

.upload-area.dragover {
  border-color: var(--accent);
  background: var(--primary-light);
}

.upload-icon {
  font-size: 3.5rem;
  margin-bottom: 1.25rem;
  opacity: 0.8;
  filter: drop-shadow(0 2px 4px rgba(0,0,0,0.1));
}

.upload-text {
  font-size: 1.25rem;
  font-weight: 600;
  color: var(--text);
  margin-bottom: 0.5rem;
}

.upload-subtext {
  font-size: 0.875rem;
  color: var(--text-secondary);
  max-width: 24ch;
  margin: 0 auto;
}

/* Controls */
.controls-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 1.5rem;
  margin-bottom: 2.5rem;
}

.control-group {
  display: flex;
  flex-direction: column;
  gap: 0.75rem;
}

.control-label {
  display: flex;
  align-items: center;
  justify-content: space-between;
  font-size: 0.875rem;
  font-weight: 600;
  color: var(--text);
}

.control-value {
  font-size: 0.75rem;
  color: var(--accent);
  font-weight: 600;
  background: var(--primary-light);
  padding: 0.25rem 0.5rem;
  border-radius: var(--radius-sm);
}

/* Toggle Switch */
.toggle-switch {
  position: relative;
  width: 52px;
  height: 28px;
  background: var(--border);
  border-radius: 14px;
  cursor: pointer;
  transition: var(--transition);
  flex-shrink: 0;
}

.toggle-switch.active {
  background: var(--accent);
}

.toggle-switch::before {
  content: '';
  position: absolute;
  top: 2px;
  left: 2px;
  width: 24px;
  height: 24px;
  background: white;
  border-radius: 50%;
  transition: transform 0.3s ease;
  box-shadow: var(--shadow-sm);
}

.toggle-switch.active::before {
  transform: translateX(24px);
}

.toggle-label {
  display: flex;
  align-items: center;
  justify-content: space-between;
  width: 100%;
}

/* Sliders */
input[type="range"] {
  width: 100%;
  height: 6px;
  border-radius: 3px;
  background: var(--border);
  outline: none;
  -webkit-appearance: none;
  margin: 0.5rem 0;
}

input[type="range"]::-webkit-slider-thumb {
  -webkit-appearance: none;
  width: 20px;
  height: 20px;
  border-radius: 50%;
  background: var(--accent);
  cursor: pointer;
  border: 3px solid var(--card);
  box-shadow: var(--shadow-md);
  transition: var(--transition);
}

input[type="range"]::-webkit-slider-thumb:hover {
  transform: scale(1.1);
  box-shadow: var(--shadow-lg);
}

/* Color Inputs */
input[type="color"] {
  width: 100%;
  height: 40px;
  border-radius: var(--radius-sm);
  border: 2px solid var(--border);
  background: transparent;
  cursor: pointer;
  transition: var(--transition);
}

input[type="color"]:hover {
  border-color: var(--accent);
  transform: translateY(-1px);
}

/* Selects */
select {
  width: 100%;
  padding: 0.75rem;
  border-radius: var(--radius-sm);
  border: 2px solid var(--border);
  background: var(--card);
  color: var(--text);
  font-size: 0.875rem;
  cursor: pointer;
  transition: var(--transition);
  outline: none;
}

select:hover {
  border-color: var(--accent);
}

/* Filter Buttons */
.filter-options {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
  gap: 0.5rem;
  margin-top: 0.5rem;
}

.filter-btn {
  padding: 0.5rem;
  background: var(--primary-light);
  border: 1px solid var(--border);
  border-radius: var(--radius-sm);
  color: var(--text);
  font-size: 0.75rem;
  font-weight: 500;
  cursor: pointer;
  transition: var(--transition);
  text-align: center;
}

.filter-btn:hover {
  border-color: var(--accent);
  transform: translateY(-1px);
}

.filter-btn.active {
  background: var(--accent);
  border-color: var(--accent);
  color: white;
}

/* Position Buttons */
.position-options {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 0.5rem;
  margin-top: 0.5rem;
}

.position-btn {
  padding: 0.75rem 0.5rem;
  background: var(--primary-light);
  border: 1px solid var(--border);
  border-radius: var(--radius-sm);
  color: var(--text);
  font-size: 0.75rem;
  font-weight: 500;
  cursor: pointer;
  transition: var(--transition);
  text-align: center;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 0.25rem;
}

.position-btn:hover {
  border-color: var(--accent);
  transform: translateY(-1px);
}

.position-btn.active {
  background: var(--accent);
  border-color: var(--accent);
  color: white;
}

.position-icon {
  font-size: 1.25rem;
  margin-bottom: 0.25rem;
}

/* Layout Options */
.layout-options {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
  gap: 0.5rem;
  margin-top: 0.5rem;
}

.layout-btn {
  padding: 0.75rem 0.5rem;
  background: var(--primary-light);
  border: 1px solid var(--border);
  border-radius: var(--radius-sm);
  color: var(--text);
  font-size: 0.75rem;
  font-weight: 500;
  cursor: pointer;
  transition: var(--transition);
  text-align: center;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 0.25rem;
}

.layout-btn:hover {
  border-color: var(--accent);
  transform: translateY(-1px);
}

.layout-btn.active {
  background: var(--accent);
  border-color: var(--accent);
  color: white;
}

.layout-icon {
  font-size: 1.25rem;
  margin-bottom: 0.25rem;
}

/* Sensor Mode Options */
.sensor-options {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
  gap: 0.5rem;
  margin-top: 0.5rem;
}

.sensor-btn {
  padding: 0.75rem 0.5rem;
  background: var(--primary-light);
  border: 1px solid var(--border);
  border-radius: var(--radius-sm);
  color: var(--text);
  font-size: 0.75rem;
  font-weight: 500;
  cursor: pointer;
  transition: var(--transition);
  text-align: center;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 0.25rem;
}

.sensor-btn:hover {
  border-color: var(--accent);
  transform: translateY(-1px);
}

.sensor-btn.active {
  background: var(--accent);
  border-color: var(--accent);
  color: white;
}

.sensor-icon {
  font-size: 1.25rem;
  margin-bottom: 0.25rem;
}

/* Canvas Preview */
.preview-wrap {
  display: flex;
  justify-content: center;
  margin: 2.5rem 0;
  position: relative;
}

.canvas-container {
  position: relative;
  max-width: 680px;
  width: 100%;
  border-radius: var(--radius-md);
  overflow: hidden;
  box-shadow: var(--shadow-lg);
  transition: var(--transition);
  border: 1px solid var(--border);
}

.canvas-container.portrait-preview {
  max-width: 480px;
}

canvas {
  display: block;
  width: 100%;
  height: auto;
  background: var(--surface);
}

/* Download Button */
.download-btn {
  display: block;
  margin: 2.5rem auto 0;
  padding: 1rem 2.5rem;
  font-size: 1rem;
  font-weight: 600;
  border-radius: var(--radius-md);
  border: none;
  background: var(--primary);
  color: white;
  cursor: pointer;
  transition: var(--transition);
  position: relative;
  overflow: hidden;
  min-width: 200px;
  letter-spacing: 0.5px;
  box-shadow: var(--shadow-md);
}

[data-theme="dark"] .download-btn {
  background: white;
  color: #000000;
}

.download-btn:hover {
  transform: translateY(-2px);
  box-shadow: var(--shadow-lg);
}

.download-btn:active {
  transform: translateY(0);
}

.download-btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
  transform: none;
  box-shadow: none;
}

/* Footer */
footer {
  text-align: center;
  margin-top: 3rem;
  color: var(--text-secondary);
  font-size: 0.875rem;
  padding-top: 1.5rem;
  border-top: 1px solid var(--border);
}

/* Font Preview */
.font-preview {
  font-size: 0.875rem;
  margin-top: 0.25rem;
  color: var(--text-secondary);
  font-style: italic;
  min-height: 1.5em;
}

/* Indicators */
.orientation-indicator,
.ratio-indicator,
.sensor-indicator {
  display: inline-block;
  padding: 0.25rem 0.5rem;
  background: var(--primary-light);
  color: var(--accent);
  border-radius: var(--radius-sm);
  font-size: 0.75rem;
  font-weight: 600;
  margin-left: 0.5rem;
}

/* Instagram Option */
.instagram-option {
  font-size: 0.75rem;
  color: var(--text-secondary);
  margin-top: 0.25rem;
}

/* Color Contrast Warning */
.contrast-warning {
  font-size: 0.75rem;
  color: #dc2626;
  margin-top: 0.25rem;
  display: flex;
  align-items: center;
  gap: 0.25rem;
}

.contrast-warning.hidden {
  display: none;
}

/* Sensor Mode Tooltip */
.sensor-tooltip {
  position: absolute;
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: var(--radius-sm);
  padding: 0.75rem;
  font-size: 0.75rem;
  max-width: 250px;
  box-shadow: var(--shadow-md);
  z-index: 100;
  pointer-events: none;
  opacity: 0;
  transition: opacity 0.2s;
}

.sensor-tooltip.show {
  opacity: 1;
}

/* Responsive */
@media (max-width: 768px) {
  .wrapper {
    padding: 1.25rem 1rem;
  }
  
  .card {
    padding: 1.5rem;
  }
  
  .upload-area {
    padding: 3rem 1rem;
  }
  
  .controls-grid {
    grid-template-columns: 1fr;
    gap: 1.25rem;
  }
  
  header {
    flex-direction: column;
    align-items: stretch;
    gap: 1.25rem;
  }
  
  .theme-toggle {
    align-self: flex-start;
  }
  
  .download-btn {
    width: 100%;
    max-width: 300px;
  }
  
  .position-options,
  .layout-options,
  .sensor-options {
    grid-template-columns: repeat(3, 1fr);
  }
  
  .filter-options {
    grid-template-columns: repeat(4, 1fr);
  }
}

@media (max-width: 480px) {
  .filter-options {
    grid-template-columns: repeat(3, 1fr);
  }
  
  .canvas-container,
  .canvas-container.portrait-preview {
    max-width: 100%;
  }
  
  .position-options,
  .layout-options,
  .sensor-options {
    grid-template-columns: repeat(2, 1fr);
  }
  
  .position-btn,
  .layout-btn,
  .sensor-btn {
    padding: 0.5rem 0.25rem;
    font-size: 0.7rem;
  }
  
  .position-icon,
  .layout-icon,
  .sensor-icon {
    font-size: 1rem;
  }
}
</style>
</head>

<body data-theme="light">

<div class="wrapper">

<header>
  <div class="header-content">
    <h1>EXIF Border Generator</h1>
    <p>Add beautiful borders with camera metadata to your photos</p>
  </div>
  <button class="theme-toggle" id="themeToggle">Dark Mode</button>
</header>

<div class="card">

  <div class="upload-area" id="upload">
    <div class="upload-icon">üì∑</div>
    <div class="upload-text">Upload Your Photo</div>
    <div class="upload-subtext">Click or drag & drop an image</div>
    <input type="file" id="fileInput" accept="image/*" hidden>
  </div>

  <div class="controls-grid">
    <!-- NEW: Sensor Mode Control -->
    <div class="control-group">
      <div class="control-label">
        <span>Sensor Mode <span id="sensorIndicator" class="sensor-indicator">Full Frame</span></span>
        <span class="control-value" id="sensorValue">Full Frame</span>
      </div>
      <div class="sensor-options">
        <button class="sensor-btn active" data-sensor="fullframe">
          <span class="sensor-icon">üì∑</span>
          <span>Full Frame</span>
        </button>
        <button class="sensor-btn" data-sensor="aps-c">
          <span class="sensor-icon">üîç</span>
          <span>APS-C (1.5x)</span>
        </button>
        <button class="sensor-btn" data-sensor="mft">
          <span class="sensor-icon">üìê</span>
          <span>MFT (2.0x)</span>
        </button>
        <button class="sensor-btn" data-sensor="canon-crop">
          <span class="sensor-icon">üìä</span>
          <span>Canon APS-C (1.6x)</span>
        </button>
      </div>
      <div style="font-size: 0.75rem; color: var(--text-secondary); margin-top: 0.5rem;">
        <strong>Full Frame:</strong> Shows 35mm equivalent (√ó1.5 from APS-C)<br>
        <strong>APS-C:</strong> Shows actual focal length (no conversion)<br>
        <strong>MFT:</strong> Shows equivalent for MFT (√ó0.75 from APS-C)<br>
        <strong>Canon APS-C:</strong> Shows equivalent for Canon (√ó0.94 from APS-C)
      </div>
    </div>

    <!-- Borderless Mode -->
    <div class="control-group">
      <div class="control-label">
        <div class="toggle-label">
          <span>Borderless Mode</span>
        </div>
        <div class="toggle-switch" id="borderlessToggle"></div>
      </div>
      <div style="font-size: 0.75rem; color: var(--text-secondary);">Place EXIF text inside photo without borders</div>
    </div>

    <!-- Text Position Control -->
    <div class="control-group">
      <div class="control-label">
        <span>Text Position</span>
        <span class="control-value" id="textPositionValue">Bottom Center</span>
      </div>
      <div class="position-options">
        <button class="position-btn" data-position="bottom-left">
          <span class="position-icon">‚ÜôÔ∏è</span>
          <span>Bottom Left</span>
        </button>
        <button class="position-btn active" data-position="bottom-center">
          <span class="position-icon">‚¨áÔ∏è</span>
          <span>Bottom Center</span>
        </button>
        <button class="position-btn" data-position="bottom-right">
          <span class="position-icon">‚ÜòÔ∏è</span>
          <span>Bottom Right</span>
        </button>
      </div>
    </div>

    <!-- Layout Options -->
    <div class="control-group">
      <div class="control-label">
        <span>EXIF Layout</span>
        <span class="control-value" id="layoutValue">Classic</span>
      </div>
      <div class="layout-options">
        <button class="layout-btn active" data-layout="classic">
          <span class="layout-icon">üìÑ</span>
          <span>Classic</span>
        </button>
        <button class="layout-btn" data-layout="compact">
          <span class="layout-icon">üìä</span>
          <span>Compact</span>
        </button>
        <button class="layout-btn" data-layout="minimal">
          <span class="layout-icon">üéØ</span>
          <span>Minimal</span>
        </button>
        <button class="layout-btn" data-layout="vertical">
          <span class="layout-icon">üìê</span>
          <span>Vertical</span>
        </button>
      </div>
    </div>

    <!-- Instagram Size Control -->
    <div class="control-group">
      <div class="control-label">
        <div class="toggle-label">
          <span>Instagram Mode</span>
          <span id="instagramRatioValue" class="ratio-indicator" style="display: none;">4:5</span>
        </div>
        <div class="toggle-switch" id="instagramToggle"></div>
      </div>
      <select id="instagramRatio" class="instagram-ratio" disabled>
        <option value="4:5">Portrait (4:5)</option>
        <option value="1:1">Square (1:1)</option>
        <option value="1.91:1">Landscape (1.91:1)</option>
      </select>
      <div class="instagram-option">Adds top/bottom borders with Instagram aspect ratios</div>
    </div>

    <div class="control-group">
      <div class="control-label">
        <span>Font Family <span id="orientationIndicator" class="orientation-indicator" style="display: none;">Portrait</span></span>
        <span class="control-value" id="fontFamilyValue">Inter</span>
      </div>
      <select id="fontFamily">
        <option value="Inter">Inter (Modern Sans)</option>
        <option value="Roboto">Roboto (Clean Sans)</option>
        <option value="Poppins">Poppins (Geometric Sans)</option>
        <option value="Montserrat">Montserrat (Elegant Sans)</option>
        <option value="Open Sans">Open Sans (Friendly Sans)</option>
        <option value="Playfair Display">Playfair Display (Elegant Serif)</option>
        <option value="Lato">Lato (Corporate Sans)</option>
        <option value="Raleway">Raleway (Stylish Sans)</option>
        <option value="Source Sans Pro">Source Sans Pro (Professional Sans)</option>
        <option value="Noto Sans">Noto Sans (Universal Sans)</option>
      </select>
      <div class="font-preview" id="fontPreview">The quick brown fox jumps over the lazy dog</div>
    </div>

    <div class="control-group">
      <div class="control-label">
        <div class="toggle-label">
          <span>Show EXIF Data</span>
        </div>
        <div class="toggle-switch active" id="exifToggle"></div>
      </div>
      <div style="font-size: 0.75rem; color: var(--text-secondary);">Toggle to show/hide camera settings</div>
    </div>

    <!-- Text Background Opacity -->
    <div class="control-group">
      <div class="control-label">
        <span>Text Background Opacity</span>
        <span class="control-value" id="textBgOpacityValue">0%</span>
      </div>
      <input type="range" id="textBgOpacity" min="0" max="100" step="5" value="0">
      <div style="font-size: 0.75rem; color: var(--text-secondary);">Opacity of the background behind text</div>
    </div>

    <!-- Text Background Color -->
    <div class="control-group">
      <div class="control-label">
        <span>Text Background Color</span>
        <span class="control-value" id="textBgColorValue">#FFFFFF</span>
      </div>
      <input type="color" id="textBgColor" value="#ffffff">
      <div class="contrast-warning hidden" id="contrastWarning">
        <span>‚ö†Ô∏è</span>
        <span>Low contrast with text color</span>
      </div>
    </div>

    <!-- ENHANCED: More Filter Options -->
    <div class="control-group">
      <div class="control-label">
        <span>Image Filter</span>
        <span class="control-value" id="filterValue">None</span>
      </div>
      <div class="filter-options">
        <button class="filter-btn active" data-filter="none">None</button>
        <button class="filter-btn" data-filter="grayscale">B&W</button>
        <button class="filter-btn" data-filter="sepia">Sepia</button>
        <button class="filter-btn" data-filter="vintage">Vintage</button>
        <button class="filter-btn" data-filter="cool">Cool</button>
        <button class="filter-btn" data-filter="warm">Warm</button>
        <button class="filter-btn" data-filter="high-contrast">Contrast</button>
        <button class="filter-btn" data-filter="kodachrome">Kodachrome</button>
        <button class="filter-btn" data-filter="polaroid">Polaroid</button>
        <button class="filter-btn" data-filter="film-grain">Film Grain</button>
        <button class="filter-btn" data-filter="instagram">Instagram</button>
        <button class="filter-btn" data-filter="lomo">Lomo</button>
        <button class="filter-btn" data-filter="cinematic">Cinematic</button>
        <button class="filter-btn" data-filter="faded">Faded</button>
        <button class="filter-btn" data-filter="dramatic">Dramatic</button>
        <button class="filter-btn" data-filter="urban">Urban</button>
      </div>
    </div>

    <div class="control-group">
      <div class="control-label">
        <span>Font Size</span>
        <span class="control-value" id="fontScaleValue">1.0</span>
      </div>
      <input type="range" id="fontScale" min="0.6" max="1.4" step="0.05" value="1">
    </div>

    <div class="control-group">
      <div class="control-label">
        <span>Line Spacing</span>
        <span class="control-value" id="lineSpacingValue">1.2</span>
      </div>
      <input type="range" id="lineSpacing" min="0.8" max="2.0" step="0.05" value="1.2">
    </div>

    <div class="control-group">
      <div class="control-label">
        <span>Border Size</span>
        <span class="control-value" id="borderSizeValue">4%</span>
      </div>
      <input type="range" id="borderSize" min="0.02" max="0.10" step="0.005" value="0.04">
    </div>

    <div class="control-group">
      <div class="control-label">
        <span>Border Color</span>
        <span class="control-value" id="borderColorValue">#FFFFFF</span>
      </div>
      <input type="color" id="borderColor" value="#ffffff">
    </div>

    <div class="control-group">
      <div class="control-label">
        <span>Text Color</span>
        <span class="control-value" id="textColorValue">#111111</span>
      </div>
      <input type="color" id="textColor" value="#111111">
      <div class="contrast-warning hidden" id="textContrastWarning">
        <span>‚ö†Ô∏è</span>
        <span>Low contrast with background</span>
      </div>
    </div>
  </div>

  <div class="preview-wrap">
    <div class="canvas-container" id="canvasContainer">
      <canvas id="previewCanvas"></canvas>
    </div>
  </div>

  <button class="download-btn" id="downloadBtn" disabled>
    Download Full Resolution
  </button>

</div>

<footer>
  <p>EXIF Border Generator ‚Ä¢ Add professional camera metadata borders to your photos</p>
  <p style="font-size: 0.75rem; margin-top: 0.5rem;">Works offline ‚Ä¢ Install as app</p>
</footer>

</div>

<script>
class EXIFBorderApp {
  constructor() {
    this.initElements();
    this.initUpload();
    this.bindControls();
    this.initTheme();
    this.initOfflineStorage();
    this.updateControlValues();
    this.updateFontPreview();
    this.initServiceWorker();
    this.checkContrast();
    
    // Performance optimizations
    this.renderQueued = false;
    this.renderThrottle = 16; // ~60fps
    
    // Auto-save settings
    const saveDebounce = this.debounce(() => this.saveSettings(), 1000);
    [this.fontScaleEl, this.lineSpacingEl, this.borderSizeEl, 
     this.borderColorEl, this.textColorEl, this.fontFamilyEl,
     this.textBgOpacityEl, this.textBgColorEl]
      .forEach(el => el.addEventListener('input', saveDebounce));
  }

  debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
      const later = () => {
        clearTimeout(timeout);
        func(...args);
      };
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
    };
  }

  initElements() {
    // Canvas elements
    this.previewCanvas = document.getElementById("previewCanvas");
    this.previewCtx = this.previewCanvas.getContext("2d", {
      alpha: true,
      desynchronized: true
    });
    this.canvasContainer = document.getElementById("canvasContainer");
    
    // Control elements
    this.orientationIndicator = document.getElementById("orientationIndicator");
    this.exifToggle = document.getElementById("exifToggle");
    this.filterValue = document.getElementById("filterValue");
    this.filterButtons = document.querySelectorAll('.filter-btn');
    
    // NEW: Sensor mode elements
    this.sensorIndicator = document.getElementById("sensorIndicator");
    this.sensorValue = document.getElementById("sensorValue");
    this.sensorButtons = document.querySelectorAll('.sensor-btn');
    
    // Borderless toggle
    this.borderlessToggle = document.getElementById("borderlessToggle");
    
    // Position elements
    this.textPositionValue = document.getElementById("textPositionValue");
    this.positionButtons = document.querySelectorAll('.position-btn');
    
    // Layout elements
    this.layoutValue = document.getElementById("layoutValue");
    this.layoutButtons = document.querySelectorAll('.layout-btn');
    
    // Instagram controls
    this.instagramToggle = document.getElementById("instagramToggle");
    this.instagramRatioEl = document.getElementById("instagramRatio");
    this.instagramRatioValue = document.getElementById("instagramRatioValue");
    
    // Text background controls
    this.textBgOpacityEl = document.getElementById("textBgOpacity");
    this.textBgOpacityValue = document.getElementById("textBgOpacityValue");
    this.textBgColorEl = document.getElementById("textBgColor");
    this.textBgColorValue = document.getElementById("textBgColorValue");
    
    // Export canvas
    this.exportCanvas = document.createElement("canvas");
    this.exportCtx = this.exportCanvas.getContext("2d");
    
    // UI elements
    this.upload = document.getElementById("upload");
    this.input = document.getElementById("fileInput");
    this.downloadBtn = document.getElementById("downloadBtn");
    
    // Control inputs
    this.fontFamilyEl = document.getElementById("fontFamily");
    this.fontScaleEl = document.getElementById("fontScale");
    this.lineSpacingEl = document.getElementById("lineSpacing");
    this.borderSizeEl = document.getElementById("borderSize");
    this.borderColorEl = document.getElementById("borderColor");
    this.textColorEl = document.getElementById("textColor");
    
    // Contrast warnings
    this.contrastWarning = document.getElementById("contrastWarning");
    this.textContrastWarning = document.getElementById("textContrastWarning");
    
    // Value display elements
    this.fontPreview = document.getElementById("fontPreview");
    this.fontFamilyValue = document.getElementById("fontFamilyValue");
    this.fontScaleValue = document.getElementById("fontScaleValue");
    this.lineSpacingValue = document.getElementById("lineSpacingValue");
    this.borderSizeValue = document.getElementById("borderSizeValue");
    this.borderColorValue = document.getElementById("borderColorValue");
    this.textColorValue = document.getElementById("textColorValue");
    
    // State
    this.image = null;
    this.filteredImage = null;
    this.exif = null;
    this.isPortrait = false;
    this.showExif = true;
    this.currentFilter = 'none';
    this.instagramMode = false;
    this.instagramRatio = "4:5";
    this.textPosition = 'bottom-center';
    this.borderlessMode = false;
    this.layout = 'classic';
    this.textBgOpacity = 0;
    this.textBgColor = "#ffffff";
    
    // NEW: Sensor mode state - FIXED LOGIC
    this.sensorMode = 'fullframe'; // 'fullframe', 'aps-c', 'mft', 'canon-crop'
    
    // Store the actual focal length from EXIF
    this.actualFocalLength = null;
  }

  initOfflineStorage() {
    if (!localStorage.getItem('exifBorderSettings')) {
      localStorage.setItem('exifBorderSettings', JSON.stringify({
        theme: 'light',
        fontSize: 1.0,
        borderSize: 0.04,
        textPosition: 'bottom-center',
        borderlessMode: false,
        layout: 'classic',
        textBgOpacity: 0,
        textBgColor: "#ffffff",
        sensorMode: 'fullframe'
      }));
    }
    
    try {
      const settings = JSON.parse(localStorage.getItem('exifBorderSettings'));
      if (settings.theme) {
        document.body.dataset.theme = settings.theme;
        this.updateThemeButton();
      }
      if (settings.textPosition) {
        this.setPosition(settings.textPosition);
      }
      if (settings.borderlessMode !== undefined) {
        this.setBorderlessMode(settings.borderlessMode);
      }
      if (settings.layout) {
        this.setLayout(settings.layout);
      }
      if (settings.textBgOpacity !== undefined) {
        this.setTextBgOpacity(settings.textBgOpacity);
      }
      if (settings.textBgColor) {
        this.setTextBgColor(settings.textBgColor);
      }
      if (settings.sensorMode) {
        this.setSensorMode(settings.sensorMode);
      }
    } catch (e) {
      console.log('No saved settings found');
    }
  }

  saveSettings() {
    const settings = {
      theme: document.body.dataset.theme,
      fontSize: this.fontScaleEl.value,
      borderSize: this.borderSizeEl.value,
      borderColor: this.borderColorEl.value,
      textColor: this.textColorEl.value,
      fontFamily: this.fontFamilyEl.value,
      showExif: this.showExif,
      instagramMode: this.instagramMode,
      textPosition: this.textPosition,
      borderlessMode: this.borderlessMode,
      layout: this.layout,
      textBgOpacity: this.textBgOpacity,
      textBgColor: this.textBgColor,
      sensorMode: this.sensorMode,
      currentFilter: this.currentFilter,
      lastUpdated: new Date().toISOString()
    };
    
    localStorage.setItem('exifBorderSettings', JSON.stringify(settings));
  }

  setSensorMode(mode) {
    this.sensorMode = mode;
    
    this.sensorButtons.forEach(btn => {
      btn.classList.remove('active');
      if (btn.dataset.sensor === mode) {
        btn.classList.add('active');
      }
    });
    
    const sensorNames = {
      'fullframe': 'Full Frame',
      'aps-c': 'APS-C (1.5x)',
      'mft': 'MFT (2.0x)',
      'canon-crop': 'Canon APS-C (1.6x)'
    };
    this.sensorValue.textContent = sensorNames[mode] || mode;
    this.sensorIndicator.textContent = sensorNames[mode].split(' (')[0];
    
    this.queueRender();
    this.saveSettings();
  }

  setBorderlessMode(enabled) {
    this.borderlessMode = enabled;
    this.borderlessToggle.classList.toggle("active", enabled);
    
    this.borderSizeEl.disabled = enabled;
    this.borderColorEl.disabled = enabled;
    
    this.queueRender();
    this.saveSettings();
  }

  setLayout(layout) {
    this.layout = layout;
    
    this.layoutButtons.forEach(btn => {
      btn.classList.remove('active');
      if (btn.dataset.layout === layout) {
        btn.classList.add('active');
      }
    });
    
    const layoutNames = {
      'classic': 'Classic',
      'compact': 'Compact',
      'minimal': 'Minimal',
      'vertical': 'Vertical'
    };
    this.layoutValue.textContent = layoutNames[layout] || layout;
    
    this.queueRender();
    this.saveSettings();
  }

  setTextBgOpacity(value) {
    this.textBgOpacity = parseInt(value);
    this.textBgOpacityValue.textContent = `${this.textBgOpacity}%`;
    this.textBgOpacityEl.value = value;
    this.checkContrast();
    this.queueRender();
    this.saveSettings();
  }

  setTextBgColor(color) {
    this.textBgColor = color;
    this.textBgColorEl.value = color;
    this.textBgColorValue.textContent = color.toUpperCase();
    this.checkContrast();
    this.queueRender();
    this.saveSettings();
  }

  setPosition(position) {
    this.textPosition = position;
    
    this.positionButtons.forEach(btn => {
      btn.classList.remove('active');
      if (btn.dataset.position === position) {
        btn.classList.add('active');
      }
    });
    
    const positionNames = {
      'bottom-left': 'Bottom Left',
      'bottom-center': 'Bottom Center',
      'bottom-right': 'Bottom Right'
    };
    this.textPositionValue.textContent = positionNames[position] || position;
    
    this.queueRender();
    this.saveSettings();
  }

  // Check contrast between text color and background color
  checkContrast() {
    const textColor = this.textColorEl.value;
    const bgColor = this.textBgColor;
    const opacity = this.textBgOpacity / 100;
    
    // Only show warning if background opacity is high enough
    if (opacity < 0.3) {
      this.contrastWarning.classList.add('hidden');
      this.textContrastWarning.classList.add('hidden');
      return;
    }
    
    // Convert hex to RGB
    const textRgb = this.hexToRgb(textColor);
    const bgRgb = this.hexToRgb(bgColor);
    
    // Calculate relative luminance
    const textLum = this.getRelativeLuminance(textRgb);
    const bgLum = this.getRelativeLuminance(bgRgb);
    
    // Calculate contrast ratio
    const contrast = textLum > bgLum 
      ? (textLum + 0.05) / (bgLum + 0.05)
      : (bgLum + 0.05) / (textLum + 0.05);
    
    // Show warning if contrast is too low (WCAG AA minimum is 4.5:1)
    if (contrast < 2.5) {
      this.contrastWarning.classList.remove('hidden');
      this.textContrastWarning.classList.remove('hidden');
    } else {
      this.contrastWarning.classList.add('hidden');
      this.textContrastWarning.classList.add('hidden');
    }
  }

  hexToRgb(hex) {
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? {
      r: parseInt(result[1], 16),
      g: parseInt(result[2], 16),
      b: parseInt(result[3], 16)
    } : { r: 0, g: 0, b: 0 };
  }

  getRelativeLuminance(rgb) {
    const sRGB = [rgb.r / 255, rgb.g / 255, rgb.b / 255];
    const adjusted = sRGB.map(c => {
      return c <= 0.03928 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);
    });
    return 0.2126 * adjusted[0] + 0.7152 * adjusted[1] + 0.0722 * adjusted[2];
  }

  initTheme() {
    const toggle = document.getElementById("themeToggle");
    const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
    const savedTheme = localStorage.getItem('theme');
    
    if (savedTheme) {
      document.body.dataset.theme = savedTheme;
    } else if (prefersDark) {
      document.body.dataset.theme = 'dark';
    }
    
    this.updateThemeButton();
    
    toggle.onclick = () => {
      const root = document.body;
      const dark = root.dataset.theme === "dark";
      root.dataset.theme = dark ? "light" : "dark";
      localStorage.setItem('theme', root.dataset.theme);
      this.updateThemeButton();
      this.saveSettings();
    };
  }

  updateThemeButton() {
    const toggle = document.getElementById("themeToggle");
    const dark = document.body.dataset.theme === "dark";
    toggle.textContent = dark ? "Light Mode" : "Dark Mode";
  }

  initUpload() {
    this.upload.onclick = () => this.input.click();

    ["dragenter","dragover"].forEach(e =>
      this.upload.addEventListener(e, ev => {
        ev.preventDefault();
        this.upload.classList.add("dragover");
      })
    );

    ["dragleave","drop"].forEach(e =>
      this.upload.addEventListener(e, ev => {
        ev.preventDefault();
        this.upload.classList.remove("dragover");
      })
    );

    this.upload.addEventListener("drop", e => {
      const file = e.dataTransfer.files[0];
      if (file?.type.startsWith("image")) this.loadImage(file);
    });

    this.input.onchange = e => this.loadImage(e.target.files[0]);
  }

  bindControls() {
    // NEW: Sensor mode buttons
    this.sensorButtons.forEach(btn => {
      btn.onclick = (e) => {
        const sensorMode = e.currentTarget.dataset.sensor;
        this.setSensorMode(sensorMode);
      };
    });

    // EXIF toggle
    this.exifToggle.onclick = () => {
      this.showExif = !this.showExif;
      this.exifToggle.classList.toggle("active");
      this.queueRender();
      this.saveSettings();
    };

    // Borderless toggle
    this.borderlessToggle.onclick = () => {
      this.setBorderlessMode(!this.borderlessMode);
    };

    // Instagram toggle
    this.instagramToggle.onclick = () => {
      this.instagramMode = !this.instagramMode;
      this.instagramToggle.classList.toggle("active");
      this.instagramRatioEl.disabled = !this.instagramMode;
      
      if (this.instagramMode) {
        this.instagramRatioValue.textContent = this.instagramRatio;
        this.instagramRatioValue.style.display = "inline-block";
      } else {
        this.instagramRatioValue.style.display = "none";
      }
      
      this.queueRender();
      this.saveSettings();
    };

    this.instagramRatioEl.onchange = () => {
      this.instagramRatio = this.instagramRatioEl.value;
      this.instagramRatioValue.textContent = this.instagramRatio;
      this.queueRender();
      this.saveSettings();
    };

    // Filter buttons
    this.filterButtons.forEach(btn => {
      btn.onclick = (e) => {
        const filter = e.target.dataset.filter;
        this.setFilter(filter);
        this.saveSettings();
      };
    });

    // Position buttons
    this.positionButtons.forEach(btn => {
      btn.onclick = (e) => {
        const position = e.currentTarget.dataset.position;
        this.setPosition(position);
      };
    });

    // Layout buttons
    this.layoutButtons.forEach(btn => {
      btn.onclick = (e) => {
        const layout = e.currentTarget.dataset.layout;
        this.setLayout(layout);
      };
    });

    // Text background opacity
    this.textBgOpacityEl.oninput = () => {
      this.setTextBgOpacity(this.textBgOpacityEl.value);
    };

    // Text background color
    this.textBgColorEl.oninput = () => {
      this.setTextBgColor(this.textBgColorEl.value);
    };

    // Update font preview when font changes
    this.fontFamilyEl.onchange = () => {
      this.updateControlValues();
      this.updateFontPreview();
      this.queueRender();
      this.saveSettings();
    };
    
    // Update all controls
    [this.fontScaleEl, this.lineSpacingEl, this.borderSizeEl, this.borderColorEl, this.textColorEl]
      .forEach(el => {
        el.oninput = () => {
          this.updateControlValues();
          this.checkContrast();
          this.queueRender();
          this.saveSettings();
        };
      });

    this.downloadBtn.onclick = () => this.download();
  }

  updateControlValues() {
    this.fontFamilyValue.textContent = this.fontFamilyEl.value.split(" (")[0];
    this.fontScaleValue.textContent = parseFloat(this.fontScaleEl.value).toFixed(2);
    this.lineSpacingValue.textContent = parseFloat(this.lineSpacingEl.value).toFixed(2);
    this.borderSizeValue.textContent = `${Math.round(parseFloat(this.borderSizeEl.value) * 100)}%`;
    this.borderColorValue.textContent = this.borderColorEl.value.toUpperCase();
    this.textColorValue.textContent = this.textColorEl.value.toUpperCase();
  }

  updateFontPreview() {
    const fontName = this.fontFamilyEl.value.split(" (")[0];
    this.fontPreview.textContent = `Preview: ${fontName} font`;
    this.fontPreview.style.fontFamily = `'${fontName}', sans-serif`;
  }

  setFilter(filter) {
    this.currentFilter = filter;
    this.filterValue.textContent = this.getFilterName(filter);
    
    this.filterButtons.forEach(btn => {
      btn.classList.remove('active');
      if (btn.dataset.filter === filter) {
        btn.classList.add('active');
      }
    });
    
    if (this.image) {
      this.applyFilterToImage();
      this.queueRender();
    }
  }

  getFilterName(filter) {
    const names = {
      'none': 'None',
      'grayscale': 'Black & White',
      'sepia': 'Sepia',
      'vintage': 'Vintage',
      'cool': 'Cool',
      'warm': 'Warm',
      'high-contrast': 'High Contrast',
      'kodachrome': 'Kodachrome',
      'polaroid': 'Polaroid',
      'film-grain': 'Film Grain',
      'instagram': 'Instagram',
      'lomo': 'Lomo',
      'cinematic': 'Cinematic',
      'faded': 'Faded',
      'dramatic': 'Dramatic',
      'urban': 'Urban'
    };
    return names[filter] || filter;
  }

  applyFilterToImage() {
    if (!this.image) return;
    
    const tempCanvas = document.createElement('canvas');
    const tempCtx = tempCanvas.getContext('2d');
    
    tempCanvas.width = this.image.width;
    tempCanvas.height = this.image.height;
    
    tempCtx.drawImage(this.image, 0, 0);
    
    const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
    const data = imageData.data;
    
    switch(this.currentFilter) {
      case 'grayscale':
        this.applyGrayscale(data);
        break;
      case 'sepia':
        this.applySepia(data);
        break;
      case 'vintage':
        this.applyVintage(data);
        break;
      case 'cool':
        this.applyCool(data);
        break;
      case 'warm':
        this.applyWarm(data);
        break;
      case 'high-contrast':
        this.applyHighContrast(data);
        break;
      case 'kodachrome':
        this.applyKodachrome(data);
        break;
      case 'polaroid':
        this.applyPolaroid(data);
        break;
      case 'film-grain':
        this.applyFilmGrain(data, tempCanvas.width, tempCanvas.height);
        break;
      case 'instagram':
        this.applyInstagram(data);
        break;
      case 'lomo':
        this.applyLomo(data);
        break;
      case 'cinematic':
        this.applyCinematic(data);
        break;
      case 'faded':
        this.applyFaded(data);
        break;
      case 'dramatic':
        this.applyDramatic(data);
        break;
      case 'urban':
        this.applyUrban(data);
        break;
      default:
        this.filteredImage = this.image;
        return;
    }
    
    tempCtx.putImageData(imageData, 0, 0);
    
    this.filteredImage = new Image();
    this.filteredImage.src = tempCanvas.toDataURL();
    
    this.filteredImage.onload = () => {
      this.queueRender();
    };
  }

  // Existing filters
  applyGrayscale(data) {
    for (let i = 0; i < data.length; i += 4) {
      const avg = (data[i] + data[i + 1] + data[i + 2]) / 3;
      data[i] = avg;
      data[i + 1] = avg;
      data[i + 2] = avg;
    }
  }

  applySepia(data) {
    for (let i = 0; i < data.length; i += 4) {
      const r = data[i];
      const g = data[i + 1];
      const b = data[i + 2];
      
      data[i] = Math.min(255, (r * 0.393) + (g * 0.769) + (b * 0.189));
      data[i + 1] = Math.min(255, (r * 0.349) + (g * 0.686) + (b * 0.168));
      data[i + 2] = Math.min(255, (r * 0.272) + (g * 0.534) + (b * 0.131));
    }
  }

  applyVintage(data) {
    for (let i = 0; i <data.length; i += 4) {
      const avg = (data[i] + data[i + 1] + data[i + 2]) / 3;
      data[i] = avg * 0.7 + data[i] * 0.3;
      data[i + 1] = avg * 0.7 + data[i + 1] * 0.3;
      data[i + 2] = avg * 0.7 + data[i + 2] * 0.3;
      
      data[i] = Math.min(255, data[i] * 1.1);
      data[i + 1] = Math.min(255, data[i + 1] * 0.9);
      data[i + 2] = Math.min(255, data[i + 2] * 0.8);
    }
  }

  applyCool(data) {
    for (let i = 0; i < data.length; i += 4) {
      data[i] = Math.max(0, data[i] * 0.9);
      data[i + 2] = Math.min(255, data[i + 2] * 1.1);
    }
  }

  applyWarm(data) {
    for (let i = 0; i < data.length; i += 4) {
      data[i] = Math.min(255, data[i] * 1.1);
      data[i + 1] = Math.min(255, data[i + 1] * 1.05);
      data[i + 2] = Math.max(0, data[i + 2] * 0.9);
    }
  }

  applyHighContrast(data) {
    for (let i = 0; i < data.length; i += 4) {
      const contrast = 1.5;
      data[i] = ((data[i] - 128) * contrast) + 128;
      data[i + 1] = ((data[i + 1] - 128) * contrast) + 128;
      data[i + 2] = ((data[i + 2] - 128) * contrast) + 128;
      
      data[i] = Math.max(0, Math.min(255, data[i]));
      data[i + 1] = Math.max(0, Math.min(255, data[i + 1]));
      data[i + 2] = Math.max(0, Math.min(255, data[i + 2]));
    }
  }

  // NEW: Kodachrome - Classic film look with rich colors
  applyKodachrome(data) {
    for (let i = 0; i < data.length; i += 4) {
      const r = data[i];
      const g = data[i + 1];
      const b = data[i + 2];
      
      // Boost reds and yellows, desaturate blues
      data[i] = Math.min(255, r * 1.2); // Boost reds
      data[i + 1] = Math.min(255, g * 1.1); // Slightly boost greens
      data[i + 2] = Math.max(0, b * 0.9); // Reduce blues
      
      // Add slight warmth
      data[i] = Math.min(255, data[i] * 1.05);
      data[i + 1] = Math.min(255, data[i + 1] * 1.02);
      
      // Increase contrast
      const avg = (data[i] + data[i + 1] + data[i + 2]) / 3;
      data[i] = avg * 0.3 + data[i] * 0.7;
      data[i + 1] = avg * 0.3 + data[i + 1] * 0.7;
      data[i + 2] = avg * 0.4 + data[i + 2] * 0.6;
    }
  }

  // NEW: Polaroid - Soft, washed out with vintage feel
  applyPolaroid(data) {
    for (let i = 0; i < data.length; i += 4) {
      const r = data[i];
      const g = data[i + 1];
      const b = data[i + 2];
      
      // Desaturate slightly
      const avg = (r + g + b) / 3;
      data[i] = avg * 0.3 + r * 0.7;
      data[i + 1] = avg * 0.3 + g * 0.7;
      data[i + 2] = avg * 0.3 + b * 0.7;
      
      // Add warm tint
      data[i] = Math.min(255, data[i] * 1.08); // More red
      data[i + 1] = Math.min(255, data[i + 1] * 1.05); // More green
      data[i + 2] = Math.max(0, data[i + 2] * 0.95); // Less blue
      
      // Reduce contrast for soft look
      data[i] = (data[i] - 128) * 0.8 + 128;
      data[i + 1] = (data[i + 1] - 128) * 0.8 + 128;
      data[i + 2] = (data[i + 2] - 128) * 0.8 + 128;
    }
  }

  // NEW: Film Grain - Adds realistic film grain texture
  applyFilmGrain(data, width, height) {
    // First apply a vintage look
    this.applyVintage(data);
    
    // Add grain overlay
    const grainIntensity = 15;
    for (let i = 0; i < data.length; i += 4) {
      const grain = (Math.random() - 0.5) * grainIntensity;
      
      data[i] = Math.max(0, Math.min(255, data[i] + grain));
      data[i + 1] = Math.max(0, Math.min(255, data[i + 1] + grain));
      data[i + 2] = Math.max(0, Math.min(255, data[i + 2] + grain));
    }
  }

  // NEW: Instagram - Modern social media filter
  applyInstagram(data) {
    for (let i = 0; i < data.length; i += 4) {
      const r = data[i];
      const g = data[i + 1];
      const b = data[i + 2];
      
      // Boost saturation slightly
      const max = Math.max(r, g, b);
      const min = Math.min(r, g, b);
      const saturation = max === 0 ? 0 : (max - min) / max;
      
      if (saturation < 0.7) {
        data[i] = Math.min(255, r * 1.1);
        data[i + 1] = Math.min(255, g * 1.1);
        data[i + 2] = Math.min(255, b * 1.1);
      }
      
      // Add slight vignette effect by darkening edges
      const x = (i / 4) % width;
      const y = Math.floor((i / 4) / width);
      const centerX = width / 2;
      const centerY = height / 2;
      const distance = Math.sqrt(Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2));
      const maxDistance = Math.sqrt(Math.pow(centerX, 2) + Math.pow(centerY, 2));
      const vignette = 1 - (distance / maxDistance) * 0.3;
      
      data[i] *= vignette;
      data[i + 1] *= vignette;
      data[i + 2] *= vignette;
      
      // Slight contrast boost
      data[i] = (data[i] - 128) * 1.1 + 128;
      data[i + 1] = (data[i + 1] - 128) * 1.1 + 128;
      data[i + 2] = (data[i + 2] - 128) * 1.1 + 128;
    }
  }

  // NEW: Lomo - Lomography effect with vignette and color shift
  applyLomo(data) {
    for (let i = 0; i < data.length; i += 4) {
      const r = data[i];
      const g = data[i + 1];
      const b = data[i + 2];
      
      // Strong color saturation
      data[i] = Math.min(255, r * 1.3); // Boost reds
      data[i + 1] = Math.min(255, g * 1.1); // Moderate boost greens
      data[i + 2] = Math.max(0, b * 0.9); // Reduce blues
      
      // Increase contrast dramatically
      data[i] = (data[i] - 128) * 1.3 + 128;
      data[i + 1] = (data[i + 1] - 128) * 1.3 + 128;
      data[i + 2] = (data[i + 2] - 128) * 1.3 + 128;
      
      // Add cyan shift to shadows
      if (data[i] < 128) data[i + 1] = Math.min(255, data[i + 1] * 1.1);
      if (data[i] < 128) data[i + 2] = Math.min(255, data[i + 2] * 1.05);
    }
  }

  // NEW: Cinematic - Movie-like look with teal and orange
  applyCinematic(data) {
    for (let i = 0; i < data.length; i += 4) {
      const r = data[i];
      const g = data[i + 1];
      const b = data[i + 2];
      
      // Teal and orange color grading
      // Reduce blues in shadows, boost in highlights
      const luminance = (r + g + b) / 3;
      
      if (luminance > 160) {
        // Highlights: warm orange
        data[i] = Math.min(255, r * 1.15);
        data[i + 1] = Math.min(255, g * 1.05);
        data[i + 2] = Math.max(0, b * 0.9);
      } else if (luminance < 96) {
        // Shadows: cool teal
        data[i] = Math.max(0, r * 0.9);
        data[i + 1] = Math.min(255, g * 1.1);
        data[i + 2] = Math.min(255, b * 1.05);
      }
      
      // Reduce overall saturation slightly
      const avg = (data[i] + data[i + 1] + data[i + 2]) / 3;
      data[i] = avg * 0.2 + data[i] * 0.8;
      data[i + 1] = avg * 0.2 + data[i + 1] * 0.8;
      data[i + 2] = avg * 0.2 + data[i + 2] * 0.8;
      
      // Crush blacks
      if (data[i] < 32) data[i] = 20;
      if (data[i + 1] < 32) data[i + 1] = 20;
      if (data[i + 2] < 32) data[i + 2] = 20;
    }
  }

  // NEW: Faded - Desaturated, washed out retro look
  applyFaded(data) {
    for (let i = 0; i < data.length; i += 4) {
      const r = data[i];
      const g = data[i + 1];
      const b = data[i + 2];
      
      // Strong desaturation
      const avg = (r + g + b) / 3;
      data[i] = avg * 0.6 + r * 0.4;
      data[i + 1] = avg * 0.6 + g * 0.4;
      data[i + 2] = avg * 0.6 + b * 0.4;
      
      // Lift blacks (make shadows brighter)
      data[i] = Math.min(255, data[i] + 20);
      data[i + 1] = Math.min(255, data[i + 1] + 20);
      data[i + 2] = Math.min(255, data[i + 2] + 20);
      
      // Reduce contrast
      data[i] = (data[i] - 128) * 0.7 + 128;
      data[i + 1] = (data[i + 1] - 128) * 0.7 + 128;
      data[i + 2] = (data[i + 2] - 128) * 0.7 + 128;
      
      // Add slight blue tint
      data[i + 2] = Math.min(255, data[i + 2] * 1.05);
    }
  }

  // NEW: Dramatic - High contrast, moody look
  applyDramatic(data) {
    for (let i = 0; i < data.length; i += 4) {
      const r = data[i];
      const g = data[i + 1];
      const b = data[i + 2];
      
      // Convert to grayscale first
      const avg = (r + g + b) / 3;
      
      // Apply S-curve for dramatic contrast
      let newValue;
      if (avg < 64) {
        newValue = avg * 0.5; // Crush shadows
      } else if (avg < 192) {
        newValue = 64 + (avg - 64) * 1.2; // Boost midtones
      } else {
        newValue = 192 + (avg - 192) * 0.8; // Compress highlights
      }
      
      // Keep some color but heavily muted
      data[i] = newValue * 0.1 + r * 0.9;
      data[i + 1] = newValue * 0.1 + g * 0.9;
      data[i + 2] = newValue * 0.1 + b * 0.9;
      
      // Deepen shadows
      if (data[i] < 64) data[i] *= 0.8;
      if (data[i + 1] < 64) data[i + 1] *= 0.8;
      if (data[i + 2] < 64) data[i + 2] *= 0.8;
    }
  }

  // NEW: Urban - Cool, gritty city look
  applyUrban(data) {
    for (let i = 0; i < data.length; i += 4) {
      const r = data[i];
      const g = data[i + 1];
      const b = data[i + 2];
      
      // Cool color temperature
      data[i] = Math.max(0, r * 0.9); // Reduce reds
      data[i + 1] = Math.min(255, g * 1.05); // Slight boost greens
      data[i + 2] = Math.min(255, b * 1.1); // Boost blues
      
      // Increase clarity (local contrast)
      const avg = (data[i] + data[i + 1] + data[i + 2]) / 3;
      if (Math.abs(data[i] - avg) > 20) data[i] = (data[i] - avg) * 1.2 + avg;
      if (Math.abs(data[i + 1] - avg) > 20) data[i + 1] = (data[i + 1] - avg) * 1.2 + avg;
      if (Math.abs(data[i + 2] - avg) > 20) data[i + 2] = (data[i + 2] - avg) * 1.2 + avg;
      
      // Add slight grain for texture
      const grain = (Math.random() - 0.5) * 8;
      data[i] = Math.max(0, Math.min(255, data[i] + grain));
      data[i + 1] = Math.max(0, Math.min(255, data[i + 1] + grain));
      data[i + 2] = Math.max(0, Math.min(255, data[i + 2] + grain));
    }
  }

  loadImage(file) {
    const img = new Image();
    img.src = URL.createObjectURL(file);

    img.onload = () => {
      this.image = img;
      this.filteredImage = img;
      
      this.isPortrait = img.height > img.width;
      this.updateOrientationIndicator();
      
      EXIF.getData(img, () => {
        const focalLength = EXIF.getTag(img, "FocalLength");
        this.actualFocalLength = focalLength ? parseFloat(focalLength) : null;
        
        this.exif = {
          make: EXIF.getTag(img, "Make"),
          model: EXIF.getTag(img, "Model"),
          focal: this.actualFocalLength,
          aperture: EXIF.getTag(img, "FNumber"),
          shutter: EXIF.getTag(img, "ExposureTime"),
          iso: EXIF.getTag(img, "ISOSpeedRatings")
        };
        this.queueRender();
        this.downloadBtn.disabled = false;
      });
    };
  }

  updateOrientationIndicator() {
    if (this.isPortrait) {
      this.orientationIndicator.textContent = "Portrait";
      this.orientationIndicator.style.display = "inline-block";
      this.canvasContainer.classList.add("portrait-preview");
    } else {
      this.orientationIndicator.textContent = "Landscape";
      this.orientationIndicator.style.display = "inline-block";
      this.canvasContainer.classList.remove("portrait-preview");
    }
  }

  getInstagramRatioValue() {
    return {
      "4:5": 4/5,
      "1:1": 1,
      "1.91:1": 1.91
    }[this.instagramRatio];
  }

  // CORRECTED: Calculate focal length based on sensor mode
  getDisplayFocalLength() {
    if (!this.actualFocalLength) return null;
    
    // We're assuming the uploaded photo is from an APS-C camera (1.5x crop)
    // The actual focal length in EXIF is what was used on the APS-C camera
    
    const actualFocalLength = this.actualFocalLength;
    
    switch(this.sensorMode) {
      case 'fullframe':
        // Convert APS-C to Full Frame equivalent: APS-C √ó 1.5 = Full Frame
        const fullFrameEquivalent = actualFocalLength * 1.5;
        return {
          display: `${Math.round(fullFrameEquivalent)}mm`,
          actual: actualFocalLength,
          equivalent: fullFrameEquivalent,
          conversion: 'APS-C ‚Üí Full Frame (√ó1.5)'
        };
        
      case 'aps-c':
        // APS-C mode: Show actual focal length (no conversion)
        return {
          display: `${Math.round(actualFocalLength)}mm`,
          actual: actualFocalLength,
          equivalent: actualFocalLength,
          conversion: 'APS-C actual'
        };
        
      case 'mft':
        // Convert APS-C to MFT equivalent:
        // APS-C 50mm √ó 1.5 = 75mm FF equivalent
        // MFT needs: 75mm √∑ 2.0 = 37.5mm MFT equivalent
        // So conversion factor: 1.5 √∑ 2.0 = 0.75
        const mftEquivalent = actualFocalLength * 0.75;
        return {
          display: `${Math.round(mftEquivalent)}mm`,
          actual: actualFocalLength,
          equivalent: mftEquivalent,
          conversion: 'APS-C ‚Üí MFT (√ó0.75)'
        };
        
      case 'canon-crop':
        // Convert APS-C (1.5x) to Canon APS-C (1.6x):
        // APS-C 50mm √ó 1.5 = 75mm FF equivalent
        // Canon APS-C needs: 75mm √∑ 1.6 = 46.875mm
        // So conversion factor: 1.5 √∑ 1.6 = 0.9375
        const canonEquivalent = actualFocalLength * 0.9375;
        return {
          display: `${Math.round(canonEquivalent)}mm`,
          actual: actualFocalLength,
          equivalent: canonEquivalent,
          conversion: 'APS-C ‚Üí Canon APS-C (√ó0.94)'
        };
        
      default:
        return {
          display: `${Math.round(actualFocalLength)}mm`,
          actual: actualFocalLength,
          equivalent: actualFocalLength,
          conversion: 'actual'
        };
    }
  }

  // FIXED: Get EXIF string with proper sensor mode logic
  getExifString(separator) {
    let exifString = "";
    
    if (this.actualFocalLength) {
      const focalData = this.getDisplayFocalLength();
      if (focalData) {
        exifString += focalData.display + separator;
      }
    }
    
    if (this.exif.aperture) exifString += "f/" + this.exif.aperture + separator;
    if (this.exif.shutter) {
      if (this.exif.shutter < 1) {
        exifString += "1/" + Math.round(1 / this.exif.shutter) + "s" + separator;
      } else {
        exifString += this.exif.shutter + "s" + separator;
      }
    }
    if (this.exif.iso) exifString += "ISO" + this.exif.iso;
    
    const sepLength = separator.length;
    if (exifString.endsWith(separator)) {
      exifString = exifString.slice(0, -sepLength);
    }
    
    return exifString.trim();
  }

  // NEW: Get camera text with model first, then brand
  getCameraText() {
    const model = this.exif.model || "";
    const make = this.exif.make || "";
    
    // Clean up common model prefixes that duplicate the brand
    const cleanedModel = model.replace(new RegExp(`^${make}\\s*`, 'i'), '').trim();
    
    if (cleanedModel && make) {
      return `${cleanedModel} ${make}`;
    } else if (cleanedModel) {
      return cleanedModel;
    } else if (make) {
      return make;
    } else {
      return "Unknown Camera";
    }
  }

  queueRender() {
    if (this.renderQueued) return;
    this.renderQueued = true;
    requestAnimationFrame(() => {
      this.renderQueued = false;
      this.render(this.previewCtx, this.previewCanvas, true);
    });
  }

  render(ctx, canvas, preview) {
    if (!this.image || !this.exif) return;

    const imageToDraw = this.filteredImage || this.image;

    // Calculate scale for preview or full resolution
    let scale;
    if (preview) {
      if (this.isPortrait) {
        scale = Math.min(1, 480 / this.image.width);
      } else {
        scale = Math.min(1, 680 / this.image.width);
      }
    } else {
      scale = 1;
    }

    const imgW = this.image.width * scale;
    const imgH = this.image.height * scale;

    const borderRatio = this.borderlessMode ? 0 : +this.borderSizeEl.value;
    
    // Calculate borders
    let side, top, bottom;
    if (this.instagramMode) {
      side = imgW * borderRatio * 0.5;
      top = imgH * borderRatio * 1.5;
      
      if (this.showExif) {
        bottom = imgH * borderRatio * 4.0;
      } else {
        bottom = imgH * borderRatio * 2.5;
      }
    } else {
      side = imgW * borderRatio;
      top = imgW * borderRatio;
      
      if (this.showExif) {
        bottom = imgH * borderRatio * (this.isPortrait ? 5.0 : 4.0);
      } else {
        bottom = imgH * borderRatio * (this.isPortrait ? 2.5 : 2.0);
      }
    }

    // Base content dimensions
    const contentWidth = imgW + side * 2;
    const contentHeight = imgH + top + bottom;

    let canvasW = contentWidth;
    let canvasH = contentHeight;
    let contentX = side;
    let contentY = top;

    // Apply Instagram padding if needed
    if (this.instagramMode) {
      const targetRatio = this.getInstagramRatioValue();
      const contentRatio = contentWidth / contentHeight;
      
      if (contentRatio > targetRatio) {
        // Content is wider than target - add vertical padding
        canvasH = contentWidth / targetRatio;
        const paddingY = (canvasH - contentHeight) / 2;
        contentY = top + paddingY;
      } else if (contentRatio < targetRatio) {
        // Content is taller than target - add horizontal padding
        canvasW = contentHeight * targetRatio;
        const paddingX = (canvasW - contentWidth) / 2;
        contentX = side + paddingX;
      }
    }

    // For borderless mode, adjust to fit image only
    if (this.borderlessMode) {
      canvasW = imgW;
      canvasH = imgH;
      contentX = 0;
      contentY = 0;
      side = 0;
      top = 0;
      bottom = 0;
    }

    canvas.width = canvasW;
    canvas.height = canvasH;

    // Fill background (only if not borderless mode)
    if (!this.borderlessMode) {
      ctx.fillStyle = this.borderColorEl.value;
      ctx.fillRect(0, 0, canvasW, canvasH);
    }

    // Draw the image
    ctx.drawImage(imageToDraw, contentX, contentY, imgW, imgH);

    const fontFamily = this.fontFamilyEl.value.split(" (")[0];
    const titleSize = Math.max(26 * scale, canvas.width / 48) * +this.fontScaleEl.value;
    const metaSize = titleSize * 0.75;
    const lineSpacing = +this.lineSpacingEl.value;

    ctx.textBaseline = "middle";
    
    // IMPORTANT: Set text color BEFORE drawing text background
    ctx.fillStyle = this.textColorEl.value;

    // Build camera text - MODEL FIRST, THEN BRAND
    const cameraText = this.getCameraText();
    
    // Calculate text positions
    const padding = 30 * scale;
    let titleY, metaY;
    
    if (this.borderlessMode) {
      // Borderless mode: Place text inside image with proper margins
      let textHeight = 0;
      if (this.showExif) {
        if (this.layout === 'vertical') {
          textHeight = titleSize * 2.5 + metaSize * 4 + padding * 2;
        } else {
          textHeight = titleSize * 1.5 + metaSize + padding * 1.5;
        }
      } else {
        textHeight = titleSize * 1.2 + padding * 1.5;
      }
      
      // Ensure text stays within image bounds
      const maxBottomY = contentY + imgH - padding;
      const minTopY = contentY + padding;
      
      // Position text from bottom with padding
      titleY = maxBottomY - (textHeight * 0.6);
      metaY = titleY + (titleSize * lineSpacing * 0.8);
      
      // Make sure text doesn't go above image
      if (titleY < minTopY) {
        titleY = minTopY + titleSize;
        metaY = titleY + (titleSize * lineSpacing * 0.8);
      }
    } else {
      // Normal border mode
      const textAreaTop = contentY + imgH;
      const textAreaHeight = bottom;
      titleY = textAreaTop + (textAreaHeight * 0.35);
      metaY = titleY + (titleSize * lineSpacing * 0.8);
    }
    
    // Draw text background if opacity > 0
    if (this.textBgOpacity > 0 && this.showExif) {
      this.drawTextBackground(ctx, contentX, contentY, imgW, imgH, titleY, metaY, titleSize, metaSize, scale, padding, cameraText);
    }
    
    // Reset text color to ensure it's visible
    ctx.fillStyle = this.textColorEl.value;
    
    if (this.showExif) {
      // Render based on selected layout
      switch(this.layout) {
        case 'classic':
          this.renderClassicLayout(ctx, contentX, imgW, titleY, metaY, titleSize, metaSize, fontFamily, lineSpacing, cameraText, padding);
          break;
        case 'compact':
          this.renderCompactLayout(ctx, contentX, imgW, titleY, metaY, titleSize, metaSize, fontFamily, lineSpacing, cameraText, padding);
          break;
        case 'minimal':
          this.renderMinimalLayout(ctx, contentX, imgW, titleY, metaY, titleSize, metaSize, fontFamily, lineSpacing, cameraText, padding);
          break;
        case 'vertical':
          this.renderVerticalLayout(ctx, contentX, imgW, titleY, metaY, titleSize, metaSize, fontFamily, lineSpacing, cameraText, padding);
          break;
      }
    } else {
      // When hiding EXIF
      this.renderNoExifLayout(ctx, contentX, imgW, titleY, titleSize, fontFamily, cameraText, padding);
    }
  }

  drawTextBackground(ctx, contentX, contentY, imgW, imgH, titleY, metaY, titleSize, metaSize, scale, padding, cameraText) {
    const bgPaddingVertical = 15 * scale;
    const bgPaddingHorizontal = 25 * scale;
    const cornerRadius = 8 * scale;
    
    // Set up font for measurement
    const fontFamily = this.fontFamilyEl.value.split(" (")[0];
    ctx.font = `400 ${titleSize}px "${fontFamily}", system-ui`;
    
    let textWidth = 0;
    let textHeight = 0;
    
    // Calculate text dimensions based on layout
    if (this.layout === 'compact') {
      let exifString = this.getExifString(" ");
      let combinedText = `Shot on ${cameraText}`;
      if (exifString.trim()) {
        combinedText += ` ‚Ä¢ ${exifString.trim()}`;
      }
      textWidth = ctx.measureText(combinedText).width;
      textHeight = titleSize + bgPaddingVertical * 2;
    } else if (this.layout === 'minimal') {
      ctx.font = `700 ${titleSize}px "${fontFamily}", system-ui`;
      textWidth = ctx.measureText(cameraText).width;
      textHeight = titleSize + metaSize + bgPaddingVertical * 2;
    } else if (this.layout === 'vertical') {
      // For vertical layout, use estimated width
      textWidth = Math.min(200 * scale, imgW - padding * 2);
      textHeight = titleSize * 2.5 + metaSize * 4 + bgPaddingVertical * 2;
    } else { // classic
      // Measure "Shot on " + camera text
      ctx.font = `400 ${titleSize}px "${fontFamily}", system-ui`;
      const shotOnWidth = ctx.measureText("Shot on ").width;
      ctx.font = `700 ${titleSize}px "${fontFamily}", system-ui`;
      const cameraWidth = ctx.measureText(cameraText).width;
      textWidth = shotOnWidth + cameraWidth;
      textHeight = titleSize * 1.5 + metaSize + bgPaddingVertical * 2;
    }
    
    // Ensure text doesn't exceed image width
    textWidth = Math.min(textWidth, imgW - padding * 2);
    
    // Calculate background position
    let bgX, bgY, bgWidth, bgHeight;
    
    bgWidth = textWidth + (bgPaddingHorizontal * 2);
    bgHeight = textHeight;
    
    // Position horizontally based on textPosition
    switch(this.textPosition) {
      case 'bottom-left':
        bgX = contentX + padding;
        break;
      case 'bottom-right':
        bgX = contentX + imgW - bgWidth - padding;
        break;
      default: // center
        bgX = contentX + (imgW - bgWidth) / 2;
        break;
    }
    
    // Position vertically - align with text
    bgY = titleY - titleSize * 0.6 - bgPaddingVertical;
    
    // Ensure background stays within bounds for borderless mode
    if (this.borderlessMode) {
      if (bgY < contentY) {
        bgY = contentY + 5;
      }
      if (bgY + bgHeight > contentY + imgH) {
        bgY = contentY + imgH - bgHeight - 5;
      }
    }
    
    // Draw rounded rectangle background with custom color and opacity
    const rgb = this.hexToRgb(this.textBgColor);
    ctx.fillStyle = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${this.textBgOpacity / 100})`;
    
    // Draw rounded rectangle
    ctx.beginPath();
    ctx.moveTo(bgX + cornerRadius, bgY);
    ctx.lineTo(bgX + bgWidth - cornerRadius, bgY);
    ctx.quadraticCurveTo(bgX + bgWidth, bgY, bgX + bgWidth, bgY + cornerRadius);
    ctx.lineTo(bgX + bgWidth, bgY + bgHeight - cornerRadius);
    ctx.quadraticCurveTo(bgX + bgWidth, bgY + bgHeight, bgX + bgWidth - cornerRadius, bgY + bgHeight);
    ctx.lineTo(bgX + cornerRadius, bgY + bgHeight);
    ctx.quadraticCurveTo(bgX, bgY + bgHeight, bgX, bgY + bgHeight - cornerRadius);
    ctx.lineTo(bgX, bgY + cornerRadius);
    ctx.quadraticCurveTo(bgX, bgY, bgX + cornerRadius, bgY);
    ctx.closePath();
    ctx.fill();
  }

  renderClassicLayout(ctx, contentX, imgW, titleY, metaY, titleSize, metaSize, fontFamily, lineSpacing, cameraText, padding) {
    // Ensure text color is set
    ctx.fillStyle = this.textColorEl.value;
    
    if (this.textPosition === 'bottom-center') {
      ctx.textAlign = "center";
      
      ctx.font = `400 ${titleSize}px "${fontFamily}", system-ui`;
      const shotOnWidth = ctx.measureText("Shot on ").width;
      const cameraWidth = ctx.measureText(cameraText).width;
      
      const totalWidth = shotOnWidth + cameraWidth;
      const maxWidth = imgW - padding * 2;
      
      if (totalWidth > maxWidth) {
        const scaleFactor = maxWidth / totalWidth;
        const adjustedTitleSize = titleSize * Math.min(scaleFactor, 1);
        
        ctx.font = `400 ${adjustedTitleSize}px "${fontFamily}", system-ui`;
        const adjustedShotOnWidth = ctx.measureText("Shot on ").width;
        
        ctx.font = `700 ${adjustedTitleSize}px "${fontFamily}", system-ui`;
        const adjustedCameraWidth = ctx.measureText(cameraText).width;
        
        const adjustedTotalWidth = adjustedShotOnWidth + adjustedCameraWidth;
        const startX = contentX + (imgW / 2) - (adjustedTotalWidth / 2);
        
        ctx.textAlign = "left";
        ctx.font = `400 ${adjustedTitleSize}px "${fontFamily}", system-ui`;
        ctx.fillText("Shot on ", startX, titleY);
        
        ctx.font = `700 ${adjustedTitleSize}px "${fontFamily}", system-ui`;
        ctx.fillText(cameraText, startX + adjustedShotOnWidth, titleY);
      } else {
        const startX = contentX + (imgW / 2) - (totalWidth / 2);
        
        ctx.textAlign = "left";
        ctx.font = `400 ${titleSize}px "${fontFamily}", system-ui`;
        ctx.fillText("Shot on ", startX, titleY);
        
        ctx.font = `700 ${titleSize}px "${fontFamily}", system-ui`;
        ctx.fillText(cameraText, startX + shotOnWidth, titleY);
      }
      
      // Draw EXIF data with sensor mode consideration
      ctx.font = `400 ${metaSize}px "${fontFamily}", system-ui`;
      ctx.textAlign = "center";
      
      let exifString = this.getExifString(" ‚Ä¢ ");
      if (exifString.trim()) {
        ctx.fillText(exifString.trim(), contentX + (imgW / 2), metaY);
      }
      
    } else if (this.textPosition === 'bottom-left') {
      const textX = contentX + padding;
      
      ctx.textAlign = "left";
      
      ctx.font = `400 ${titleSize}px "${fontFamily}", system-ui`;
      ctx.fillText("Shot on ", textX, titleY);
      
      const shotOnWidth = ctx.measureText("Shot on ").width;
      
      ctx.font = `700 ${titleSize}px "${fontFamily}", system-ui`;
      ctx.fillText(cameraText, textX + shotOnWidth, titleY);
      
      // Draw EXIF data with sensor mode consideration
      ctx.font = `400 ${metaSize}px "${fontFamily}", system-ui`;
      
      let exifString = this.getExifString(" ‚Ä¢ ");
      if (exifString.trim()) {
        ctx.fillText(exifString.trim(), textX, metaY);
      }
      
    } else if (this.textPosition === 'bottom-right') {
      const maxTextX = contentX + imgW - padding;
      
      ctx.textAlign = "right";
      
      // Measure text widths
      ctx.font = `400 ${titleSize}px "${fontFamily}", system-ui`;
      const shotOnWidth = ctx.measureText("Shot on ").width;
      
      ctx.font = `700 ${titleSize}px "${fontFamily}", system-ui`;
      const cameraWidth = ctx.measureText(cameraText).width;
      
      const textX = maxTextX;
      
      // Draw camera brand/model first
      ctx.font = `700 ${titleSize}px "${fontFamily}", system-ui`;
      ctx.fillText(cameraText, textX, titleY);
      
      // Then draw "Shot on " to the left
      ctx.font = `400 ${titleSize}px "${fontFamily}", system-ui`;
      ctx.fillText("Shot on ", textX - cameraWidth, titleY);
      
      // Draw EXIF data with sensor mode consideration
      ctx.font = `400 ${metaSize}px "${fontFamily}", system-ui`;
      
      let exifString = this.getExifString(" ‚Ä¢ ");
      if (exifString.trim()) {
        ctx.fillText(exifString.trim(), textX, metaY);
      }
    }
  }

  renderCompactLayout(ctx, contentX, imgW, titleY, metaY, titleSize, metaSize, fontFamily, lineSpacing, cameraText, padding) {
    // Ensure text color is set
    ctx.fillStyle = this.textColorEl.value;
    
    // Combined line: "Shot on Camera ‚Ä¢ EXIF data"
    let combinedText = `Shot on ${cameraText}`;
    let exifString = this.getExifString(" ");
    
    if (exifString.trim()) {
      combinedText += ` ‚Ä¢ ${exifString.trim()}`;
    }
    
    ctx.font = `500 ${titleSize}px "${fontFamily}", system-ui`;
    const textWidth = ctx.measureText(combinedText).width;
    const maxWidth = imgW - padding * 2;
    
    if (this.textPosition === 'bottom-center') {
      ctx.textAlign = "center";
      
      if (textWidth > maxWidth) {
        const scaleFactor = maxWidth / textWidth;
        const adjustedTitleSize = titleSize * Math.min(scaleFactor, 1);
        ctx.font = `500 ${adjustedTitleSize}px "${fontFamily}", system-ui`;
      }
      ctx.fillText(combinedText, contentX + (imgW / 2), titleY);
      
    } else if (this.textPosition === 'bottom-left') {
      const textX = contentX + padding;
      ctx.textAlign = "left";
      ctx.fillText(combinedText, textX, titleY);
      
    } else if (this.textPosition === 'bottom-right') {
      const maxTextX = contentX + imgW - padding;
      ctx.textAlign = "right";
      ctx.fillText(combinedText, maxTextX, titleY);
    }
  }

  renderMinimalLayout(ctx, contentX, imgW, titleY, metaY, titleSize, metaSize, fontFamily, lineSpacing, cameraText, padding) {
    // Ensure text color is set
    ctx.fillStyle = this.textColorEl.value;
    
    if (this.textPosition === 'bottom-center') {
      ctx.textAlign = "center";
      
      ctx.font = `700 ${titleSize}px "${fontFamily}", system-ui`;
      const textWidth = ctx.measureText(cameraText).width;
      const maxWidth = imgW - padding * 2;
      
      if (textWidth > maxWidth) {
        const scaleFactor = maxWidth / textWidth;
        const adjustedTitleSize = titleSize * Math.min(scaleFactor, 1);
        ctx.font = `700 ${adjustedTitleSize}px "${fontFamily}", system-ui`;
      }
      ctx.fillText(cameraText, contentX + (imgW / 2), titleY);
      
      // EXIF data in smaller font below
      ctx.font = `300 ${metaSize * 0.9}px "${fontFamily}", system-ui`;
      
      let exifString = this.getExifString("  ");
      if (exifString.trim()) {
        ctx.fillText(exifString.trim(), contentX + (imgW / 2), metaY);
      }
      
    } else if (this.textPosition === 'bottom-left') {
      const textX = contentX + padding;
      
      ctx.textAlign = "left";
      ctx.font = `700 ${titleSize}px "${fontFamily}", system-ui`;
      ctx.fillText(cameraText, textX, titleY);
      
      // EXIF data
      ctx.font = `300 ${metaSize * 0.9}px "${fontFamily}", system-ui`;
      
      let exifString = this.getExifString("  ");
      if (exifString.trim()) {
        ctx.fillText(exifString.trim(), textX, metaY);
      }
      
    } else if (this.textPosition === 'bottom-right') {
      const maxTextX = contentX + imgW - padding;
      
      ctx.textAlign = "right";
      ctx.font = `700 ${titleSize}px "${fontFamily}", system-ui`;
      ctx.fillText(cameraText, maxTextX, titleY);
      
      // EXIF data
      ctx.font = `300 ${metaSize * 0.9}px "${fontFamily}", system-ui`;
      
      let exifString = this.getExifString("  ");
      if (exifString.trim()) {
        ctx.fillText(exifString.trim(), maxTextX, metaY);
      }
    }
  }

  renderVerticalLayout(ctx, contentX, imgW, titleY, metaY, titleSize, metaSize, fontFamily, lineSpacing, cameraText, padding) {
    // Ensure text color is set
    ctx.fillStyle = this.textColorEl.value;
    
    const verticalSpacing = titleSize * lineSpacing * 0.7;
    
    if (this.textPosition === 'bottom-center') {
      ctx.textAlign = "center";
      const centerX = contentX + (imgW / 2);
      
      // Camera brand
      ctx.font = `700 ${titleSize}px "${fontFamily}", system-ui`;
      ctx.fillText(cameraText, centerX, titleY);
      
      // EXIF data items vertically with sensor mode consideration
      ctx.font = `400 ${metaSize}px "${fontFamily}", system-ui`;
      let yPos = titleY + verticalSpacing;
      
      if (this.actualFocalLength) {
        const focalData = this.getDisplayFocalLength();
        if (focalData) {
          ctx.fillText(focalData.display, centerX, yPos);
          yPos += verticalSpacing;
        }
      }
      if (this.exif.aperture) {
        ctx.fillText(`f/${this.exif.aperture}`, centerX, yPos);
        yPos += verticalSpacing;
      }
      if (this.exif.shutter) {
        const shutterText = this.exif.shutter < 1 ? 
          `1/${Math.round(1 / this.exif.shutter)}s` : `${this.exif.shutter}s`;
        ctx.fillText(shutterText, centerX, yPos);
        yPos += verticalSpacing;
      }
      if (this.exif.iso) {
        ctx.fillText(`ISO${this.exif.iso}`, centerX, yPos);
      }
      
    } else if (this.textPosition === 'bottom-left') {
      const textX = contentX + padding;
      
      ctx.textAlign = "left";
      
      // Camera brand
      ctx.font = `700 ${titleSize}px "${fontFamily}", system-ui`;
      ctx.fillText(cameraText, textX, titleY);
      
      // EXIF data items vertically with sensor mode consideration
      ctx.font = `400 ${metaSize}px "${fontFamily}", system-ui`;
      let yPos = titleY + verticalSpacing;
      
      if (this.actualFocalLength) {
        const focalData = this.getDisplayFocalLength();
        if (focalData) {
          ctx.fillText(focalData.display, textX, yPos);
          yPos += verticalSpacing;
        }
      }
      if (this.exif.aperture) {
        ctx.fillText(`f/${this.exif.aperture}`, textX, yPos);
        yPos += verticalSpacing;
      }
      if (this.exif.shutter) {
        const shutterText = this.exif.shutter < 1 ? 
          `1/${Math.round(1 / this.exif.shutter)}s` : `${this.exif.shutter}s`;
        ctx.fillText(shutterText, textX, yPos);
        yPos += verticalSpacing;
      }
      if (this.exif.iso) {
        ctx.fillText(`ISO${this.exif.iso}`, textX, yPos);
      }
      
    } else if (this.textPosition === 'bottom-right') {
      const maxTextX = contentX + imgW - padding;
      
      ctx.textAlign = "right";
      
      // Camera brand
      ctx.font = `700 ${titleSize}px "${fontFamily}", system-ui`;
      ctx.fillText(cameraText, maxTextX, titleY);
      
      // EXIF data items vertically with sensor mode consideration
      ctx.font = `400 ${metaSize}px "${fontFamily}", system-ui`;
      let yPos = titleY + verticalSpacing;
      
      if (this.actualFocalLength) {
        const focalData = this.getDisplayFocalLength();
        if (focalData) {
          ctx.fillText(focalData.display, maxTextX, yPos);
          yPos += verticalSpacing;
        }
      }
      if (this.exif.aperture) {
        ctx.fillText(`f/${this.exif.aperture}`, maxTextX, yPos);
        yPos += verticalSpacing;
      }
      if (this.exif.shutter) {
        const shutterText = this.exif.shutter < 1 ? 
          `1/${Math.round(1 / this.exif.shutter)}s` : `${this.exif.shutter}s`;
        ctx.fillText(shutterText, maxTextX, yPos);
        yPos += verticalSpacing;
      }
      if (this.exif.iso) {
        ctx.fillText(`ISO${this.exif.iso}`, maxTextX, yPos);
      }
    }
  }

  renderNoExifLayout(ctx, contentX, imgW, titleY, titleSize, fontFamily, cameraText, padding) {
    // Ensure text color is set
    ctx.fillStyle = this.textColorEl.value;
    
    if (this.textPosition === 'bottom-center') {
      ctx.textAlign = "center";
      
      ctx.font = `400 ${titleSize}px "${fontFamily}", system-ui`;
      const shotOnWidth = ctx.measureText("Shot on ").width;
      const cameraWidth = ctx.measureText(cameraText).width;
      
      const totalWidth = shotOnWidth + cameraWidth;
      const maxWidth = imgW - padding * 2;
      
      if (totalWidth > maxWidth) {
        const scaleFactor = maxWidth / totalWidth;
        const adjustedTitleSize = titleSize * Math.min(scaleFactor, 1);
        
        ctx.font = `400 ${adjustedTitleSize}px "${fontFamily}", system-ui`;
        const adjustedShotOnWidth = ctx.measureText("Shot on ").width;
        
        ctx.font = `700 ${adjustedTitleSize}px "${fontFamily}", system-ui`;
        const adjustedCameraWidth = ctx.measureText(cameraText).width;
        
        const adjustedTotalWidth = adjustedShotOnWidth + adjustedCameraWidth;
        const startX = contentX + (imgW / 2) - (adjustedTotalWidth / 2);
        
        ctx.textAlign = "left";
        ctx.font = `400 ${adjustedTitleSize}px "${fontFamily}", system-ui`;
        ctx.fillText("Shot on ", startX, titleY);
        
        ctx.font = `700 ${adjustedTitleSize}px "${fontFamily}", system-ui`;
        ctx.fillText(cameraText, startX + adjustedShotOnWidth, titleY);
      } else {
        const startX = contentX + (imgW / 2) - (totalWidth / 2);
        
        ctx.textAlign = "left";
        ctx.font = `400 ${titleSize}px "${fontFamily}", system-ui`;
        ctx.fillText("Shot on ", startX, titleY);
        
        ctx.font = `700 ${titleSize}px "${fontFamily}", system-ui`;
        ctx.fillText(cameraText, startX + shotOnWidth, titleY);
      }
      
    } else if (this.textPosition === 'bottom-left') {
      const textX = contentX + padding;
      
      ctx.textAlign = "left";
      
      ctx.font = `400 ${titleSize}px "${fontFamily}", system-ui`;
      ctx.fillText("Shot on ", textX, titleY);
      
      const shotOnWidth = ctx.measureText("Shot on ").width;
      
      ctx.font = `700 ${titleSize}px "${fontFamily}", system-ui`;
      ctx.fillText(cameraText, textX + shotOnWidth, titleY);
      
    } else if (this.textPosition === 'bottom-right') {
      const maxTextX = contentX + imgW - padding;
      
      ctx.textAlign = "right";
      
      ctx.font = `400 ${titleSize}px "${fontFamily}", system-ui`;
      const shotOnWidth = ctx.measureText("Shot on ").width;
      
      ctx.font = `700 ${titleSize}px "${fontFamily}", system-ui`;
      const cameraWidth = ctx.measureText(cameraText).width;
      
      const textX = maxTextX;
      
      // Draw camera brand/model first
      ctx.font = `700 ${titleSize}px "${fontFamily}", system-ui`;
      ctx.fillText(cameraText, textX, titleY);
      
      // Then draw "Shot on " to the left
      ctx.font = `400 ${titleSize}px "${fontFamily}", system-ui`;
      ctx.fillText("Shot on ", textX - cameraWidth, titleY);
    }
  }

  download() {
    this.render(this.exportCtx, this.exportCanvas, false);
    const a = document.createElement("a");
    const mode = this.instagramMode ? "instagram-" : "exif-border-";
    const sensorMode = this.sensorMode !== 'fullframe' ? `${this.sensorMode}-` : '';
    const filterMode = this.currentFilter !== 'none' ? `${this.currentFilter}-` : '';
    a.download = `${filterMode}${sensorMode}${mode}${new Date().getTime()}.jpg`;
    a.href = this.exportCanvas.toDataURL("image/jpeg", 0.98);
    a.click();
  }

  initServiceWorker() {
    if ('serviceWorker' in navigator && location.protocol === 'https:') {
      navigator.serviceWorker.register('sw.js').catch(console.log);
    }
  }
}

// Initialize app
document.addEventListener('DOMContentLoaded', () => {
  const app = new EXIFBorderApp();
  window.app = app;
});

// PWA installation
window.addEventListener('beforeinstallprompt', (e) => {
  e.preventDefault();
  setTimeout(() => {
    const installBtn = document.createElement('button');
    installBtn.textContent = 'üì± Install App';
    installBtn.style.cssText = `
      position: fixed;
      bottom: 20px;
      right: 20px;
      padding: 10px 20px;
      background: var(--accent);
      color: white;
      border: none;
      border-radius: 20px;
      font-size: 14px;
      cursor: pointer;
      z-index: 1000;
      box-shadow: 0 2px 10px rgba(0,0,0,0.2);
    `;
    installBtn.onclick = () => e.prompt();
    document.body.appendChild(installBtn);
    
    setTimeout(() => installBtn.remove(), 10000);
  }, 3000);
});
</script>
</body>
</html>